{"key":"site-code-structure","url":"https://blog.aquariuslt.com/posts/2016/03/06/site-code-structure","path":"/posts/2016/03/06/site-code-structure","title":"Site 项目结构介绍 | Aquariuslt Blog","breadcrumbs":{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","item":"https://blog.aquariuslt.com","name":"Aquariuslt Blog","position":1},{"@type":"ListItem","item":"https://blog.aquariuslt.com/posts","name":"Posts","position":2},{"@type":"ListItem","item":"https://blog.aquariuslt.com/posts/2016/03/06/site-code-structure","name":"Site 项目结构介绍","position":3}]},"type":"DETAIL","metas":[{"name":"og:site_name","content":"Aquariuslt Blog"},{"name":"og:type","content":"website"},{"name":"og:title","content":"Site 项目结构介绍"},{"name":"og:description","content":"应该说是第一个 Node.js 建站项目. 目的是用于替换 JavaWeb 的后台而且可以在过程中练习一下调节样式的水平.项目本身的结构是从JShelf开始. 是由于公司内部组织了一次 MEAN 的一些入门分享. 分成了几个小组,我们小组根据对 MEAN 的认识魔改了这样一个基本的项目基础结构. 在其原本的结构上.做了做了一些蛋疼的修改大概是根据npm install的提示,更换 lib 的名字或者升级 lib 的版本到最新版. 然后删除了一些没必要的模块.\n"},{"name":"og:image","content":"./cover.png"},{"name":"og:type","content":"article"}],"data":{"title":"Site 项目结构介绍","id":"site-code-structure","created":"2016-03-06T00:00:00.000Z","updated":"2016-03-06T00:00:00.000Z","categories":[{"id":"blog","label":"Blog","total":0,"link":"/categories/blog"}],"tags":[{"id":"node","label":"Node","total":0,"link":"/tags/node"},{"id":"javascript","label":"JavaScript","total":1,"link":"/tags/javascript"}],"cover":"/posts/2016/03/06/site-code-structure/cover.png","images":["./build-flow.png"],"toc":[{"label":"Site 项目结构介绍","level":1,"id":"site-项目结构介绍","position":0,"children":[{"label":"Background","level":2,"id":"background","position":1,"children":[],"pid":0},{"label":"Agenda","level":2,"id":"agenda","position":2,"children":[],"pid":0},{"label":"Thought","level":2,"id":"thought","position":3,"children":[],"pid":0},{"label":"Code Structure","level":2,"id":"code-structure","position":4,"children":[{"label":"Folder TreeView","level":3,"id":"folder-treeview","position":5,"children":[],"pid":4},{"label":"Review with Java-Web Project","level":3,"id":"review-with-java-web-project","position":6,"children":[],"pid":4},{"label":"Files & Folders","level":3,"id":"files-folders","position":7,"children":[{"label":"package.json","level":4,"id":"packagejson","position":8,"children":[],"pid":7},{"label":"src","level":4,"id":"src","position":9,"children":[],"pid":7},{"label":"gulp","level":4,"id":"gulp","position":10,"children":[],"pid":7},{"label":"dist","level":4,"id":"dist","position":11,"children":[],"pid":7}],"pid":4}],"pid":0},{"label":"GulpTask","level":2,"id":"gulptask","position":12,"children":[{"label":"Gulp","level":3,"id":"gulp","position":13,"children":[{"label":"What is Gulp","level":4,"id":"what-is-gulp","position":14,"children":[],"pid":13},{"label":"How to Use","level":4,"id":"how-to-use","position":15,"children":[],"pid":13}],"pid":12},{"label":"Build Flow","level":3,"id":"build-flow","position":16,"children":[{"label":"index","level":4,"id":"index","position":17,"children":[],"pid":16},{"label":"styles","level":4,"id":"styles","position":18,"children":[],"pid":16}],"pid":12},{"label":"images,fonts,assets","level":3,"id":"imagesfontsassets","position":19,"children":[],"pid":12},{"label":"templates","level":3,"id":"templates","position":20,"children":[],"pid":12},{"label":"webpack/browserify","level":3,"id":"webpackbrowserify","position":21,"children":[],"pid":12},{"label":"minify","level":3,"id":"minify","position":22,"children":[],"pid":12}],"pid":0}],"pid":-1}],"summary":"应该说是第一个 Node.js 建站项目. 目的是用于替换 JavaWeb 的后台而且可以在过程中练习一下调节样式的水平.项目本身的结构是从JShelf开始. 是由于公司内部组织了一次 MEAN 的一些入门分享. 分成了几个小组,我们小组根据对 MEAN 的认识魔改了这样一个基本的项目基础结构. 在其原本的结构上.做了做了一些蛋疼的修改大概是根据npm install的提示,更换 lib 的名字或者升级 lib 的版本到最新版. 然后删除了一些没必要的模块.\n","src":"\n# Site 项目结构介绍\n\n## Background\n\n应该说是第一个 Node.js 建站项目. 目的是用于替换 JavaWeb 的后台而且可以在过程中练习一下调节样式的水平.\n\n项目本身的结构是从[JShelf](https://github.com/Dantemo/JShelf)开始. 是由于公司内部组织了一次 MEAN 的一些入门分享. 分成了几个小组,我们小组根据对 MEAN 的认识魔改了这样一个基本的项目基础结构. 在其原本的结构上.做了做了一些蛋疼的修改大概是根据`npm install`的提示,更换 lib 的名字或者升级 lib 的版本到最新版. 然后删除了一些没必要的模块.\n\n目前已经在我的 VPS 上运行,[主站](https://aquariuslt.com)是目前的效果.\n\n## Agenda\n\n整个项目的结构从以下几个部分开始介绍,但是在过程中会交错穿插一点互相引用的地方.\n\n- 运作思路\n- 代码结构\n- 构建过程\n- 运行准备\n\n## Thought\n\n从 Coding 的角度出发,`Node.js`作为服务器端语言的优势之一就是不需要编译,直接重启 node 进程即可. 而前端代码呢,在开发的时候,我们希望能够达到所见即所得的方式,即 html+样式的修改能够直接呈现在页面上. 在生产环境的时候,为了加快访问速度,对前端代码进行必要的打包,压缩,混淆等操作.\n\n作为单页应用的一部分,希望能够进行自动引入所需的 js 文件,不需要手动维护首页 html 里面的直接饮用\n\n按照这个想法,理想中的前端开发顺序希望是这样:\n\n- 开发环境\n\n  > 1. 以符合`RequireJS规范`编写前端代码\n  > 2. 前端的 html,css,js 代码一旦有改动,且通过了 IDE 的 jshint 与 html 格式化检查,立刻热替换到所展示的页面中\n\n- 生产环境\n  > 1. 将写好的前端代码打包\n  > 2. 服务器将前端的首页,以及打包后的 js,css 文件,释放出一个可访问的 url 作为前端资源文件的全部\n\n## Code Structure\n\n### Folder TreeView\n\n首先我们来看一下项目的目录结构:\n\n> 这是一个遍历到子文件夹 5 层的项目结构目录. 已经去除 `node_modules`文件夹和 IDE 的文件夹\n\n```\n├── dist\n│   ├── build\n│   │   ├── bundle.css\n│   │   ├── bundle.js\n│   │   ├── fonts\n│   │   │   ├── glyphicons-halflings-regular.eot\n│   │   │   ├── glyphicons-halflings-regular.svg\n│   │   │   ├── glyphicons-halflings-regular.ttf\n│   │   │   ├── glyphicons-halflings-regular.woff\n│   │   │   └── glyphicons-halflings-regular.woff2\n│   │   └── index.html\n│   └── tmp\n│       └── templates.js\n├── gulp\n│   ├── client\n│   │   ├── assets.js\n│   │   ├── browserify.js\n│   │   ├── clean.js\n│   │   ├── default.js\n│   │   ├── fonts.js\n│   │   ├── images.js\n│   │   ├── core.store.js\n│   │   ├── minify.js\n│   │   ├── serve.js\n│   │   ├── styles.js\n│   │   ├── templates.js\n│   │   ├── watch.js\n│   │   ├── watchify.js\n│   │   ├── webpack-watch.js\n│   │   └── webpack.js\n│   ├── config.js\n│   ├── core.store.js\n│   └── server\n│       ├── core.store.js\n│       └── server.js\n├── gulpfile.js\n├── node_modules\n├── package.json\n├── readme.md\n├── server.js\n├── src\n│   ├── client\n│   │   ├── home\n│   │   │   ├── controllers\n│   │   │   │   ├── activities.controller.js\n│   │   │   │   ├── header.controller.js\n│   │   │   │   ├── home.controller.js\n│   │   │   │   └── picture.slide.controller.js\n│   │   │   ├── filters\n│   │   │   │   ├── activity.array.filter.js\n│   │   │   │   └── activity.publish.filter.js\n│   │   │   ├── core.store.js\n│   │   │   ├── routes\n│   │   │   │   └── home.routes.js\n│   │   │   ├── styles\n│   │   │   │   ├── about.css\n│   │   │   │   ├── angular-ui-bootstrap.css\n│   │   │   │   ├── bootstrap-theme.css\n│   │   │   │   ├── bootstrap.css\n│   │   │   │   ├── common.css\n│   │   │   │   └── home.css\n│   │   │   └── views\n│   │   │       ├── home.about.html\n│   │   │       ├── home.footer.html\n│   │   │       ├── home.header.html\n│   │   │       └── home.index.html\n│   │   ├── index.html\n│   │   └── core.store.js\n│   └── server\n│       └── home\n│           ├── config\n│           │   └── activities.config.js\n│           ├── controllers\n│           │   └── activities.controller.js\n│           └── routes\n│               └── home.routes.js\n└── tree.txt\n\n2381 directories, 10428 files\n\n```\n\n### Review with Java-Web Project\n\n回想一下使用 maven 进行依赖管理的简单 Java Web 项目. 大致是以下一种目录:\n\n```\n├── pom.xml\n├── src\n│   ├── main\n│   │   ├── java\n│   │   │   └── com\n│   │   │       └── aquariuslt\n│   │   └── webapp\n│   │       ├── WEB-INF\n│   │       │   ├── mvc-dispatcher-servlet.xml\n│   │       │   └── web.xml\n│   │       ├── booking-create.html\n│   │       └── js\n│   │           ├── booking\n│   │           └── extjs\n│   └── test\n│       └── java\n│           └── com\n│               ├── aquariuslt\n│               └── springapp\n└── target\n    ├── ITA-BookingUI\n    │   ├── META-INF\n    │   │   └── MANIFEST.MF\n    │   ├── WEB-INF\n    │   │   ├── classes\n    │   │   │   └── com\n    │   │   ├── lib\n    │   │   │   ├── aopalliance-1.0.jar\n    │   │   │   ├── commons-logging-1.2.jar\n    │   │   │   ├── freemarker-2.3.23.jar\n    │   │   │   ├── jackson-core-asl-1.9.13.jar\n    │   │   │   ├── jackson-mapper-asl-1.9.13.jar\n    │   │   │   ├── servlet-api-2.5.jar\n    │   │   │   ├── spring-aop-4.2.0.RELEASE.jar\n    │   │   │   ├── spring-beans-4.2.0.RELEASE.jar\n    │   │   │   ├── spring-context-4.2.0.RELEASE.jar\n    │   │   │   ├── spring-context-support-4.2.0.RELEASE.jar\n    │   │   │   ├── spring-core-4.2.0.RELEASE.jar\n    │   │   │   ├── spring-expression-4.2.0.RELEASE.jar\n    │   │   │   ├── spring-web-4.2.0.RELEASE.jar\n    │   │   │   ├── spring-webmvc-4.2.0.RELEASE.jar\n    │   │   │   └── tomcat-servlet-api-7.0.63.jar\n    │   │   ├── mvc-dispatcher-servlet.xml\n    │   │   └── web.xml\n    │   ├── booking-create.html\n    │   └── js\n    │       ├── booking\n    │       │   ├── BookingCreateApp.js\n    │       │   ├── controller\n    │       │   └── view\n    │       └── extjs\n    │           ├── ext-all-debug.js\n    │           ├── ext-theme-neptune\n    │           └── resources\n    ├── ITA-BookingUI.war\n    ├── classes\n    │   └── com\n    │       └── aquariuslt\n    │           └── ita\n    ├── generated-sources\n    │   └── annotations\n    ├── generated-test-sources\n    │   └── test-annotations\n    └── test-classes\n        └── com\n            └── aquariuslt\n                └── ita\n\n41 directories, 28 files\n```\n\n> `src`文件夹作为源代码目录 `src->main->java`下的代码作为后台的代码 `src->main->webapp`作为运行时 web 应用容器的配置,包含了前端的资源文件 `pom.xml`作为项目的依赖管理,命名选项配置文件 `target`文件夹则是通过 maven 构建命令编译构建出来的 输出目录\n\n### Files & Folders\n\n#### package.json\n\n功能等同`pom.xml`\n\n#### src\n\n源代码文件夹. 其中往下分可以分成前端模块和后端模块两个大部分为了方便分类,将它分成了`client`,`server` 源代码的子层级命名方式为`module`-`mvc feature`-`submodule`\n\n#### gulp\n\n存放`GulpTask`的文件夹. 子文件夹又分成`client`和`server`的 tasks. 至于使用 Gulp 来进行什么样的构建,在下一部分会说明\n\n#### dist\n\n构建出来的前端输出文件夹.类似于 JavaWeb 里面的 target. 但是仅限前端. 这里存放的是经过打包后的前端资源. 在整个应用启动的时候,将会扫描该文件夹,将其全部作为静态资源暴露出 url.\n\n## GulpTask\n\n### Gulp\n\n#### What is Gulp\n\n[Gulp 官方网站](https://gulpjs.com/) Gulp.js 是一个自动化构建工具，开发者可以使用它在项目开发过程中自动执行常见任务。\n\n#### How to Use\n\n我使用 gulp 来干什么呢? 单从前端运行的过程来说.我使用 Gulp 的 Task 进行下面一个流程. ![](./build-flow.png)\n\n### Build Flow\n\n为了达到最终的目的:单页应用输出最终的一个页面.\n\n```html\n<!DOCTYPE html>\n<html ng-app=\"home\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n    <link rel=\"shortcut icon\" href=\"https://avatars3.githubusercontent.com/u/6554061?v=3&s=460\" />\n    <title>Aquariuslt Home</title>\n    <link href=\"bundle.min.css\" rel=\"stylesheet\" />\n  </head>\n  <body>\n    <header\n      ng-include=\"'home/views/home.header.html'\"\n      class=\"navbar navbar-default navbar-fixed-top navbar-inner\"\n    ></header>\n    <div class=\"page-header\"></div>\n    <div ui-view></div>\n    <script src=\"bundle.min.js\"></script>\n    <footer ng-include=\"'home/views/home.footer.html'\" class=\"footer\"></footer>\n  </body>\n</html>\n```\n\n我们需要怎么构建出这样一个页面呢? 按照我的 gulp tasks 代码上是这样:\n\n```js\n//按照以下顺序运行task\nif (process.env.NODE_ENV == 'release') {\n  runSequence(\n    'clean',\n    ['index', 'styles', 'images', 'fonts', 'assets', 'templates'],\n    //'browserify',\n    'webpack',\n    'minify',\n    'server'\n  );\n}\n```\n\n前面第一个 clean 只是清除 dist 文件夹的任务而已而已.\n\n一开始,`index.html`只是这样:\n\n```html\n<!DOCTYPE html>\n<html ng-app=\"home\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"shortcut icon\" href=\"https://avatars3.githubusercontent.com/u/6554061?v=3&s=460\" />\n    <title>Aquariuslt Home</title>\n    <!--styles-->\n  </head>\n  <body>\n    <header\n      ng-include=\"'home/views/home.header.html'\"\n      class=\"navbar navbar-default navbar-fixed-top navbar-inner\"\n    ></header>\n    <div class=\"page-header\"></div>\n    <div ui-view></div>\n    <!--scripts-->\n    <footer ng-include=\"'home/views/home.footer.html'\" class=\"footer\"></footer>\n  </body>\n</html>\n```\n\n#### index\n\n`index`这个 task,主要功能是读取构建的一个配置文件`config.js`获取`index.html`的路径. 紧接着比较傻逼的将 html 中的\n\n```htmlbars\n<!--styles-->\n```\n\n替换成\n\n```htmlbars\n<link href=\"bundle.min.css\" rel=\"stylesheet\">\n```\n\n将\n\n```htmlbars\n<!--scripts-->\n```\n\n替换成\n\n```htmlbars\n<script src=\"bundle.min.js\"></script>\n```\n\n虽然 css,js 还没有经过打包.但是先替换,存放在 dist 文件夹下.\n\n#### styles\n\n在配置文件`config.js`里面,需要维护一个 css 文件夹的正则路径.匹配到多个路径下的 css 位置供扫描. css 文件的路径大概是这样子的:\n\n```\nstyles: [config.folder.src + '/client/**/styles/*.css'],\n```\n\n即 src 文件夹下,匹配到 client 下的隔层文件夹里的所有叫`styles`的子文件夹下的所有 css 文件 `styles`主要是将扫描出来的所有 css 文件打包在一起,融合成 刚刚替换成的`bundle.min.js`\n\n### images,fonts,assets\n\n这三个 tasks 功能类似.即也是读取配置文件所维护的一个匹配所有静态资源文件将其放到 dist 下对应的文件夹内.\n\n### templates\n\n在配置文件`config.js`,控制将一个负责控制所有视图(views)的路径\n\n```\ntemplates: config.folder.src + '/client/**/*.html',\n```\n\n`templates`这个 tasks 主要是扫描所有`.html`的视图文件,用于生成一些 `ngTempalte`供 angular 调用 html 模板其实最后这些生成的模板将会合并进 js 中. 大概会变成下面这样:\n\n```js\nmodule.exports = angular.module('templates', []).run([\n  '$templateCache',\n  function($templateCache) {\n    $templateCache.put(\n      'index.html',\n      '<!DOCTYPE html>\\n<html ng-app=\"home\">\\n  <head>\\n    <meta charset=\"utf-8\">\\n    ...'\n    );\n    $templateCache.put(\n      'home/views/home.about.html',\n      '<div role=\"main\" class=\"container\">\\n  <div class=\"row\">\\n    <...'\n    );\n    $templateCache.put(\n      'home/views/home.footer.html',\n      '<div class=\"container\">\\n  <div class=\"center-block\">\\n    <h5>B...'\n    );\n    $templateCache.put(\n      'home/views/home.header.html',\n      '<div class=\"container\" ng-controller=\"headerController\">\\n  <div...'\n    );\n    $templateCache.put(\n      'home/views/home.index.html',\n      '<div class=\"container\">\\n  <div class=\"jumbotron\">\\n    <div clas...'\n    );\n  }\n]);\n```\n\n### webpack/browserify\n\n这两个是现在主流的 js 打包工具.配合自身的一些插件.主要做到能够将以`requirejs`方式编的方式的代码. 为了方便开发和调试, `webpack`和`browserify`都有一个热打包插件:过程都是监听所有 js 源代码的路径.当文件更新的时候,自动在打包一次.部署到运行的服务器上.\n\n### minify\n\n这个以前叫做 uglify,就是压缩 js 代码,变量名混淆.\n","html":"<h1>Site 项目结构介绍</h1>\n<h2>Background</h2>\n<p>应该说是第一个 Node.js 建站项目. 目的是用于替换 JavaWeb 的后台而且可以在过程中练习一下调节样式的水平.</p>\n<p>项目本身的结构是从<a href=\"https://github.com/Dantemo/JShelf\">JShelf</a>开始. 是由于公司内部组织了一次 MEAN 的一些入门分享. 分成了几个小组,我们小组根据对 MEAN 的认识魔改了这样一个基本的项目基础结构. 在其原本的结构上.做了做了一些蛋疼的修改大概是根据<code>npm install</code>的提示,更换 lib 的名字或者升级 lib 的版本到最新版. 然后删除了一些没必要的模块.</p>\n<p>目前已经在我的 VPS 上运行,<a href=\"https://aquariuslt.com\">主站</a>是目前的效果.</p>\n<h2>Agenda</h2>\n<p>整个项目的结构从以下几个部分开始介绍,但是在过程中会交错穿插一点互相引用的地方.</p>\n<ul>\n<li>运作思路</li>\n<li>代码结构</li>\n<li>构建过程</li>\n<li>运行准备</li>\n</ul>\n<h2>Thought</h2>\n<p>从 Coding 的角度出发,<code>Node.js</code>作为服务器端语言的优势之一就是不需要编译,直接重启 node 进程即可. 而前端代码呢,在开发的时候,我们希望能够达到所见即所得的方式,即 html+样式的修改能够直接呈现在页面上. 在生产环境的时候,为了加快访问速度,对前端代码进行必要的打包,压缩,混淆等操作.</p>\n<p>作为单页应用的一部分,希望能够进行自动引入所需的 js 文件,不需要手动维护首页 html 里面的直接饮用</p>\n<p>按照这个想法,理想中的前端开发顺序希望是这样:</p>\n<ul>\n<li>\n<p>开发环境</p>\n<blockquote>\n<ol>\n<li>以符合<code>RequireJS规范</code>编写前端代码</li>\n<li>前端的 html,css,js 代码一旦有改动,且通过了 IDE 的 jshint 与 html 格式化检查,立刻热替换到所展示的页面中</li>\n</ol>\n</blockquote>\n</li>\n<li>\n<p>生产环境</p>\n<blockquote>\n<ol>\n<li>将写好的前端代码打包</li>\n<li>服务器将前端的首页,以及打包后的 js,css 文件,释放出一个可访问的 url 作为前端资源文件的全部</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<h2>Code Structure</h2>\n<h3>Folder TreeView</h3>\n<p>首先我们来看一下项目的目录结构:</p>\n<blockquote>\n<p>这是一个遍历到子文件夹 5 层的项目结构目录. 已经去除 <code>node_modules</code>文件夹和 IDE 的文件夹</p>\n</blockquote>\n<pre><code>├── dist\n│   ├── build\n│   │   ├── bundle.css\n│   │   ├── bundle.js\n│   │   ├── fonts\n│   │   │   ├── glyphicons-halflings-regular.eot\n│   │   │   ├── glyphicons-halflings-regular.svg\n│   │   │   ├── glyphicons-halflings-regular.ttf\n│   │   │   ├── glyphicons-halflings-regular.woff\n│   │   │   └── glyphicons-halflings-regular.woff2\n│   │   └── index.html\n│   └── tmp\n│       └── templates.js\n├── gulp\n│   ├── client\n│   │   ├── assets.js\n│   │   ├── browserify.js\n│   │   ├── clean.js\n│   │   ├── default.js\n│   │   ├── fonts.js\n│   │   ├── images.js\n│   │   ├── core.store.js\n│   │   ├── minify.js\n│   │   ├── serve.js\n│   │   ├── styles.js\n│   │   ├── templates.js\n│   │   ├── watch.js\n│   │   ├── watchify.js\n│   │   ├── webpack-watch.js\n│   │   └── webpack.js\n│   ├── config.js\n│   ├── core.store.js\n│   └── server\n│       ├── core.store.js\n│       └── server.js\n├── gulpfile.js\n├── node_modules\n├── package.json\n├── readme.md\n├── server.js\n├── src\n│   ├── client\n│   │   ├── home\n│   │   │   ├── controllers\n│   │   │   │   ├── activities.controller.js\n│   │   │   │   ├── header.controller.js\n│   │   │   │   ├── home.controller.js\n│   │   │   │   └── picture.slide.controller.js\n│   │   │   ├── filters\n│   │   │   │   ├── activity.array.filter.js\n│   │   │   │   └── activity.publish.filter.js\n│   │   │   ├── core.store.js\n│   │   │   ├── routes\n│   │   │   │   └── home.routes.js\n│   │   │   ├── styles\n│   │   │   │   ├── about.css\n│   │   │   │   ├── angular-ui-bootstrap.css\n│   │   │   │   ├── bootstrap-theme.css\n│   │   │   │   ├── bootstrap.css\n│   │   │   │   ├── common.css\n│   │   │   │   └── home.css\n│   │   │   └── views\n│   │   │       ├── home.about.html\n│   │   │       ├── home.footer.html\n│   │   │       ├── home.header.html\n│   │   │       └── home.index.html\n│   │   ├── index.html\n│   │   └── core.store.js\n│   └── server\n│       └── home\n│           ├── config\n│           │   └── activities.config.js\n│           ├── controllers\n│           │   └── activities.controller.js\n│           └── routes\n│               └── home.routes.js\n└── tree.txt\n\n2381 directories, 10428 files\n\n</code></pre>\n<h3>Review with Java-Web Project</h3>\n<p>回想一下使用 maven 进行依赖管理的简单 Java Web 项目. 大致是以下一种目录:</p>\n<pre><code>├── pom.xml\n├── src\n│   ├── main\n│   │   ├── java\n│   │   │   └── com\n│   │   │       └── aquariuslt\n│   │   └── webapp\n│   │       ├── WEB-INF\n│   │       │   ├── mvc-dispatcher-servlet.xml\n│   │       │   └── web.xml\n│   │       ├── booking-create.html\n│   │       └── js\n│   │           ├── booking\n│   │           └── extjs\n│   └── test\n│       └── java\n│           └── com\n│               ├── aquariuslt\n│               └── springapp\n└── target\n    ├── ITA-BookingUI\n    │   ├── META-INF\n    │   │   └── MANIFEST.MF\n    │   ├── WEB-INF\n    │   │   ├── classes\n    │   │   │   └── com\n    │   │   ├── lib\n    │   │   │   ├── aopalliance-1.0.jar\n    │   │   │   ├── commons-logging-1.2.jar\n    │   │   │   ├── freemarker-2.3.23.jar\n    │   │   │   ├── jackson-core-asl-1.9.13.jar\n    │   │   │   ├── jackson-mapper-asl-1.9.13.jar\n    │   │   │   ├── servlet-api-2.5.jar\n    │   │   │   ├── spring-aop-4.2.0.RELEASE.jar\n    │   │   │   ├── spring-beans-4.2.0.RELEASE.jar\n    │   │   │   ├── spring-context-4.2.0.RELEASE.jar\n    │   │   │   ├── spring-context-support-4.2.0.RELEASE.jar\n    │   │   │   ├── spring-core-4.2.0.RELEASE.jar\n    │   │   │   ├── spring-expression-4.2.0.RELEASE.jar\n    │   │   │   ├── spring-web-4.2.0.RELEASE.jar\n    │   │   │   ├── spring-webmvc-4.2.0.RELEASE.jar\n    │   │   │   └── tomcat-servlet-api-7.0.63.jar\n    │   │   ├── mvc-dispatcher-servlet.xml\n    │   │   └── web.xml\n    │   ├── booking-create.html\n    │   └── js\n    │       ├── booking\n    │       │   ├── BookingCreateApp.js\n    │       │   ├── controller\n    │       │   └── view\n    │       └── extjs\n    │           ├── ext-all-debug.js\n    │           ├── ext-theme-neptune\n    │           └── resources\n    ├── ITA-BookingUI.war\n    ├── classes\n    │   └── com\n    │       └── aquariuslt\n    │           └── ita\n    ├── generated-sources\n    │   └── annotations\n    ├── generated-test-sources\n    │   └── test-annotations\n    └── test-classes\n        └── com\n            └── aquariuslt\n                └── ita\n\n41 directories, 28 files\n</code></pre>\n<blockquote>\n<p><code>src</code>文件夹作为源代码目录 <code>src-&gt;main-&gt;java</code>下的代码作为后台的代码 <code>src-&gt;main-&gt;webapp</code>作为运行时 web 应用容器的配置,包含了前端的资源文件 <code>pom.xml</code>作为项目的依赖管理,命名选项配置文件 <code>target</code>文件夹则是通过 maven 构建命令编译构建出来的 输出目录</p>\n</blockquote>\n<h3>Files &amp; Folders</h3>\n<h4>package.json</h4>\n<p>功能等同<code>pom.xml</code></p>\n<h4>src</h4>\n<p>源代码文件夹. 其中往下分可以分成前端模块和后端模块两个大部分为了方便分类,将它分成了<code>client</code>,<code>server</code> 源代码的子层级命名方式为<code>module</code>-<code>mvc feature</code>-<code>submodule</code></p>\n<h4>gulp</h4>\n<p>存放<code>GulpTask</code>的文件夹. 子文件夹又分成<code>client</code>和<code>server</code>的 tasks. 至于使用 Gulp 来进行什么样的构建,在下一部分会说明</p>\n<h4>dist</h4>\n<p>构建出来的前端输出文件夹.类似于 JavaWeb 里面的 target. 但是仅限前端. 这里存放的是经过打包后的前端资源. 在整个应用启动的时候,将会扫描该文件夹,将其全部作为静态资源暴露出 url.</p>\n<h2>GulpTask</h2>\n<h3>Gulp</h3>\n<h4>What is Gulp</h4>\n<p><a href=\"https://gulpjs.com/\">Gulp 官方网站</a> Gulp.js 是一个自动化构建工具，开发者可以使用它在项目开发过程中自动执行常见任务。</p>\n<h4>How to Use</h4>\n<p>我使用 gulp 来干什么呢? 单从前端运行的过程来说.我使用 Gulp 的 Task 进行下面一个流程. <img src=\"/posts/2016/03/06/site-code-structure/build-flow.png\" alt=\"\"></p>\n<h3>Build Flow</h3>\n<p>为了达到最终的目的:单页应用输出最终的一个页面.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE html&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">ng-app</span>=<span class=\"hljs-string\">\"home\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">\"utf-8\"</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"viewport\"</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">\"width=device-width,initial-scale=1\"</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">link</span> <span class=\"hljs-attr\">rel</span>=<span class=\"hljs-string\">\"shortcut icon\"</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"https://avatars3.githubusercontent.com/u/6554061?v=3&amp;s=460\"</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>Aquariuslt Home<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">link</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"bundle.min.css\"</span> <span class=\"hljs-attr\">rel</span>=<span class=\"hljs-string\">\"stylesheet\"</span> /&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">header</span>\n      <span class=\"hljs-attr\">ng-include</span>=<span class=\"hljs-string\">\"'home/views/home.header.html'\"</span>\n      <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"navbar navbar-default navbar-fixed-top navbar-inner\"</span>\n    &gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">header</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"page-header\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">ui-view</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"bundle.min.js\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">footer</span> <span class=\"hljs-attr\">ng-include</span>=<span class=\"hljs-string\">\"'home/views/home.footer.html'\"</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"footer\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">footer</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span>\n</code></pre>\n<p>我们需要怎么构建出这样一个页面呢? 按照我的 gulp tasks 代码上是这样:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">//按照以下顺序运行task</span>\n<span class=\"hljs-keyword\">if</span> (process.env.NODE_ENV == <span class=\"hljs-string\">'release'</span>) {\n  runSequence(\n    <span class=\"hljs-string\">'clean'</span>,\n    [<span class=\"hljs-string\">'index'</span>, <span class=\"hljs-string\">'styles'</span>, <span class=\"hljs-string\">'images'</span>, <span class=\"hljs-string\">'fonts'</span>, <span class=\"hljs-string\">'assets'</span>, <span class=\"hljs-string\">'templates'</span>],\n    <span class=\"hljs-comment\">//'browserify',</span>\n    <span class=\"hljs-string\">'webpack'</span>,\n    <span class=\"hljs-string\">'minify'</span>,\n    <span class=\"hljs-string\">'server'</span>\n  );\n}\n</code></pre>\n<p>前面第一个 clean 只是清除 dist 文件夹的任务而已而已.</p>\n<p>一开始,<code>index.html</code>只是这样:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE html&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">ng-app</span>=<span class=\"hljs-string\">\"home\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">\"utf-8\"</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"viewport\"</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">\"width=device-width, initial-scale=1\"</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">link</span> <span class=\"hljs-attr\">rel</span>=<span class=\"hljs-string\">\"shortcut icon\"</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"https://avatars3.githubusercontent.com/u/6554061?v=3&amp;s=460\"</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>Aquariuslt Home<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n    <span class=\"hljs-comment\">&lt;!--styles--&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">header</span>\n      <span class=\"hljs-attr\">ng-include</span>=<span class=\"hljs-string\">\"'home/views/home.header.html'\"</span>\n      <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"navbar navbar-default navbar-fixed-top navbar-inner\"</span>\n    &gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">header</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"page-header\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">ui-view</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-comment\">&lt;!--scripts--&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">footer</span> <span class=\"hljs-attr\">ng-include</span>=<span class=\"hljs-string\">\"'home/views/home.footer.html'\"</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"footer\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">footer</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span>\n</code></pre>\n<h4>index</h4>\n<p><code>index</code>这个 task,主要功能是读取构建的一个配置文件<code>config.js</code>获取<code>index.html</code>的路径. 紧接着比较傻逼的将 html 中的</p>\n<pre><code class=\"hljs htmlbars\"><span class=\"xml\"><span class=\"hljs-comment\">&lt;!--styles--&gt;</span>\n</span></code></pre>\n<p>替换成</p>\n<pre><code class=\"hljs htmlbars\"><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">link</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"bundle.min.css\"</span> <span class=\"hljs-attr\">rel</span>=<span class=\"hljs-string\">\"stylesheet\"</span>&gt;</span>\n</span></code></pre>\n<p>将</p>\n<pre><code class=\"hljs htmlbars\"><span class=\"xml\"><span class=\"hljs-comment\">&lt;!--scripts--&gt;</span>\n</span></code></pre>\n<p>替换成</p>\n<pre><code class=\"hljs htmlbars\"><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"bundle.min.js\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</span></code></pre>\n<p>虽然 css,js 还没有经过打包.但是先替换,存放在 dist 文件夹下.</p>\n<h4>styles</h4>\n<p>在配置文件<code>config.js</code>里面,需要维护一个 css 文件夹的正则路径.匹配到多个路径下的 css 位置供扫描. css 文件的路径大概是这样子的:</p>\n<pre><code>styles: [config.folder.src + '/client/**/styles/*.css'],\n</code></pre>\n<p>即 src 文件夹下,匹配到 client 下的隔层文件夹里的所有叫<code>styles</code>的子文件夹下的所有 css 文件 <code>styles</code>主要是将扫描出来的所有 css 文件打包在一起,融合成 刚刚替换成的<code>bundle.min.js</code></p>\n<h3>images,fonts,assets</h3>\n<p>这三个 tasks 功能类似.即也是读取配置文件所维护的一个匹配所有静态资源文件将其放到 dist 下对应的文件夹内.</p>\n<h3>templates</h3>\n<p>在配置文件<code>config.js</code>,控制将一个负责控制所有视图(views)的路径</p>\n<pre><code>templates: config.folder.src + '/client/**/*.html',\n</code></pre>\n<p><code>templates</code>这个 tasks 主要是扫描所有<code>.html</code>的视图文件,用于生成一些 <code>ngTempalte</code>供 angular 调用 html 模板其实最后这些生成的模板将会合并进 js 中. 大概会变成下面这样:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-built_in\">module</span>.exports = angular.module(<span class=\"hljs-string\">'templates'</span>, []).run([\n  <span class=\"hljs-string\">'$templateCache'</span>,\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">$templateCache</span>) </span>{\n    $templateCache.put(\n      <span class=\"hljs-string\">'index.html'</span>,\n      <span class=\"hljs-string\">'&lt;!DOCTYPE html&gt;\\n&lt;html ng-app=\"home\"&gt;\\n  &lt;head&gt;\\n    &lt;meta charset=\"utf-8\"&gt;\\n    ...'</span>\n    );\n    $templateCache.put(\n      <span class=\"hljs-string\">'home/views/home.about.html'</span>,\n      <span class=\"hljs-string\">'&lt;div role=\"main\" class=\"container\"&gt;\\n  &lt;div class=\"row\"&gt;\\n    &lt;...'</span>\n    );\n    $templateCache.put(\n      <span class=\"hljs-string\">'home/views/home.footer.html'</span>,\n      <span class=\"hljs-string\">'&lt;div class=\"container\"&gt;\\n  &lt;div class=\"center-block\"&gt;\\n    &lt;h5&gt;B...'</span>\n    );\n    $templateCache.put(\n      <span class=\"hljs-string\">'home/views/home.header.html'</span>,\n      <span class=\"hljs-string\">'&lt;div class=\"container\" ng-controller=\"headerController\"&gt;\\n  &lt;div...'</span>\n    );\n    $templateCache.put(\n      <span class=\"hljs-string\">'home/views/home.index.html'</span>,\n      <span class=\"hljs-string\">'&lt;div class=\"container\"&gt;\\n  &lt;div class=\"jumbotron\"&gt;\\n    &lt;div clas...'</span>\n    );\n  }\n]);\n</code></pre>\n<h3>webpack/browserify</h3>\n<p>这两个是现在主流的 js 打包工具.配合自身的一些插件.主要做到能够将以<code>requirejs</code>方式编的方式的代码. 为了方便开发和调试, <code>webpack</code>和<code>browserify</code>都有一个热打包插件:过程都是监听所有 js 源代码的路径.当文件更新的时候,自动在打包一次.部署到运行的服务器上.</p>\n<h3>minify</h3>\n<p>这个以前叫做 uglify,就是压缩 js 代码,变量名混淆.</p>\n","disqus":{"shortname":"aquariuslt","url":"https://blog.aquariuslt.com/posts/2016/03/06/site-code-structure","identifier":"-posts-2016-03-06-site-code-structure"}}}